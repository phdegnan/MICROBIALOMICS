.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "A5UD_PIPELINE 1"
.TH A5UD_PIPELINE 1 "2013-01-13" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
a5_pipeline.pl \-\- Assemble isolate genomes from Illumina data with ease
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
a5_pipeline.pl takes FastQ format sequence reads directly from the Illumina base-calling software and cleans, filters, and assembles them.
For example the command:
.PP
a5_pipeline.pl [options] read1.fastq read2.fastq my_assembly
.PP
Will assemble the paired reads in read1.fastq and read2.fastq and store the result in files whose names begin with \*(L"my_assembly\*(R".
The final scaffolded assembly will be named my_assembly.final.scaffolds.fasta
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The flow of execution is roughly:
   1) Clean up the sequence data
      \- Error correct, trim adapter, quality trim
   2) Build contigs on error-corrected reads
   3) Scaffold contigs using paired-read and mate-pair information
   4) Detect any misassemblies and break contigs/scaffolds
   5) Rescaffold the broken contigs/scaffolds
.PP
Throughout the pipeline there are various steps used to estimate
alignment parameters
.SH "EXAMPLES"
.IX Header "EXAMPLES"
With a single paired-end illumina library:
a5_pipeline.pl <read1.fastq> <read2.fastq> <output directory or basename>
.PP
With two or more libraries:
a5_pipeline.pl <library file> <output directory or basename>
.SH "AUTHORS"
.IX Header "AUTHORS"
Andrew Tritt <atritt@ucdavis.edu>
Aaron Darling <aarondarling@ucdavis.edu>
.SH "AVAILABILITY"
.IX Header "AVAILABILITY"
http://ngopt.googlecode.com
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2010, 2011
This software is licensed under the terms of the GPLv3
.IP "get_availmem Reads total installed memory in a platform-dependent way" 4
.IX Item "get_availmem Reads total installed memory in a platform-dependent way"
.PD 0
.IP "" 4
.PD
Read a single entry from an Illumina-platform generated FastQ file, and removed the paired 
read id (e.g. \*(L"/1\*(R") from the end of the read id
.IP "" 4
3\-read sequencing protocols can set the paired read \s-1ID\s0 to /3 instead of /2
and some softwares don't like this
.IP "qfilter_paired_easy" 4
.IX Item "qfilter_paired_easy"
Preprocess paired reads with \s-1SGA\s0 by filtering and quality trimming. Discard unpaired reads.
.IP "qfilter_correct_tagdust_paired" 4
.IX Item "qfilter_correct_tagdust_paired"
Preprocesses paired reads with \s-1SGA\s0 by filtering low quality reads, quality trimming, 
and discarding unpaired reads. After preprocessing reads, error corrects reads and 
removes potential contaminants using TagDust.
.Sp
Takes 4 parameters: \f(CW$r1file\fR, \f(CW$r2file\fR, \f(CW$t\fR, and \f(CW$lib\fR
where 
	\f(CW$r1file\fR = read 1 in paired reads
	\f(CW$r2file\fR = read 2 in paired reads.
	\f(CW$t\fR = the number of threads to use when running \s-1SGA\s0
	\f(CW$lib\fR = the library name to use for output generating throughout this subroutine
.IP "get_phred64 Returns whether or not the given FastQ file has phred64 quality scores" 4
.IX Item "get_phred64 Returns whether or not the given FastQ file has phred64 quality scores"
.PD 0
.IP "sga_clean Clean reads using \s-1SGA\s0. Multi-thread if running in linux environment." 4
.IX Item "sga_clean Clean reads using SGA. Multi-thread if running in linux environment."
.PD
Takes two parameters: an basename for output, \f(CW$outbase\fR, and a reference to a hash storing library information, \f(CW$libsref\fR.
.Sp
First, error correct all reads together to prepare for building contigs using \s-1IDBA\s0. To do so, this function passes all 
fastq files into the following command:
.Sp
.Vb 1
\&        sga preprocess \-q SGA_Q_TRIM \-f SGA_Q_FILTER \-m SGA_MIN_READ_LENGTH \-\-permute\-ambiguous <fastq1> <fastq2> . . . <fastqN>
.Ve
.Sp
applying the \-\-phred64 flag to sga if phred\-64 quality scores are detected, and writing preprocessed reads to \f(CW$outbase\fR.pp.fastq.
.Sp
\&\f(CW$outbase\fR.pp.fastq is indexed using the following command:
.Sp
.Vb 1
\&        sga index \-d 0.5*AVAL_SYSTEM_MEMORY \-t <n_threads> $outbase.pp.fastq
.Ve
.Sp
\&\f(CW$outbase\fR.pp.fastq is error corrected using the following command:
.Sp
.Vb 1
\&        sga correct \-t <n_threads> \-o $outbase.pp.ec.fa $outbase.pp.fastq
.Ve
.Sp
For the indexing and correcting step, n_threads is to 1 if running in a Macintosh environment, 4 otherwise.
.Sp
Second, for each paired library in \f(CW$libsref\fR, error correct reads from each library individually for scaffolding using
the qfilter_correct_tagdust_paired function.
.IP "check_and_unzip Check if the given file is zipped up. If it is, unzip and return the file it was unzipped to." 4
.IX Item "check_and_unzip Check if the given file is zipped up. If it is, unzip and return the file it was unzipped to."
.PD 0
.ie n .IP "map_all_libs Maps all librarie back to the final scaffolds generated by the A5 pipeline. Takes two parameters: $outbase, $libsref" 4
.el .IP "map_all_libs Maps all librarie back to the final scaffolds generated by the A5 pipeline. Takes two parameters: \f(CW$outbase\fR, \f(CW$libsref\fR" 4
.IX Item "map_all_libs Maps all librarie back to the final scaffolds generated by the A5 pipeline. Takes two parameters: $outbase, $libsref"
.PD
where 
	\f(CW$outbase\fR = the basename for output files generated throughout this subroutine
	\f(CW$libsref\fR = a hash storing information on all the libraries passed in.
.IP "read_lib_file" 4
.IX Item "read_lib_file"
Parses the library file, returning the given information stored in a hash. 
Takes a singled parameter: \f(CW$libfile\fR, the path to the library file to be parsed.
.Sp
Returns a hash of hashes index as such: \f(CW$hash\fR{$library}{$component}
where \f(CW$component\fR = 'up' || 'p1' || 'p2' || 'ins' || 'id'
.IP "read_file Read in entire file, returning its contents as a single string." 4
.IX Item "read_file Read in entire file, returning its contents as a single string."
.PD 0
.IP "fastq_to_fasta Convert a fastq file to fasta." 4
.IX Item "fastq_to_fasta Convert a fastq file to fasta."
.IP "split_shuif Splits a shuffled (a.k.a. interleaved) fastq file into two separate fastq files." 4
.IX Item "split_shuif Splits a shuffled (a.k.a. interleaved) fastq file into two separate fastq files."
.PD
Takes two parameters: \f(CW$shuf\fR, \f(CW$outbase\fR
where
	\f(CW$shuf\fR = the shuffled fastq file to split
	\f(CW$outbase\fR = the basename for the two fastq files resulting from splitting \f(CW$shuf\fR. The two files output
	           are \f(CW$outbase_p1\fR.fastq and \f(CW$outbase_p2\fR.fastq
.ie n .IP "tagdust Run TagDust to remove any Illumina artifacts. The sequences for the artifact sequences must be stored in $DIR/../adapter.fasta, where $DIR is the location of this executable." 4
.el .IP "tagdust Run TagDust to remove any Illumina artifacts. The sequences for the artifact sequences must be stored in \f(CW$DIR\fR/../adapter.fasta, where \f(CW$DIR\fR is the location of this executable." 4
.IX Item "tagdust Run TagDust to remove any Illumina artifacts. The sequences for the artifact sequences must be stored in $DIR/../adapter.fasta, where $DIR is the location of this executable."
Takes two parameters: \f(CW$outbase\fR, \f(CW$readsfile\fR
where
	\f(CW$outbase\fR = the basename for output generated throughout this subroutine
	\f(CW$readsfile\fR = the path to the file containing the reads for remove artifact from.
.ie n .IP "idba_assemble Assemble reads using \s-1IDBA\s0. Takes 3 parameters: $outbase, $reads, $maxrdlen where $outbase = the basename for output generated throughout this subroutine $reads = the path to the file containing the reads to assemble into contigs $maxrdlen = the maximum kmer to iterate up to." 4
.el .IP "idba_assemble Assemble reads using \s-1IDBA\s0. Takes 3 parameters: \f(CW$outbase\fR, \f(CW$reads\fR, \f(CW$maxrdlen\fR where \f(CW$outbase\fR = the basename for output generated throughout this subroutine \f(CW$reads\fR = the path to the file containing the reads to assemble into contigs \f(CW$maxrdlen\fR = the maximum kmer to iterate up to." 4
.IX Item "idba_assemble Assemble reads using IDBA. Takes 3 parameters: $outbase, $reads, $maxrdlen where $outbase = the basename for output generated throughout this subroutine $reads = the path to the file containing the reads to assemble into contigs $maxrdlen = the maximum kmer to iterate up to."
.PD 0
.IP "scaffold_sspace Scaffold contigs using \s-1SSPACE\s0." 4
.IX Item "scaffold_sspace Scaffold contigs using SSPACE."
.PD
Takes 3 or 4 parameters: \f(CW$outbase\fR, \f(CW$libsref\fR, \f(CW$curr_ctgs\fR, \f(CW$rescaffold\fR (optional)
where
	\f(CW$outbase\fR = the basename for output generated throughout this subroutine
	\f(CW$libsref\fR = a hash storing information on all the libraries passed in.
	\f(CW$curr_ctgs\fR = the contigs to scaffold
	\f(CW$rescaffold\fR = a binary value indicating whether or not we are scaffolding our assembly 
                  for the first time (i.e. scaffolding contigs generated from \s-1IDBA\s0), indicated 
                  by a 0, or if we are scaffolding for the second time (i.e. scaffolding 
                  scaffolds broken by the A5qc algorithm), indicated by a 1.
.Sp
Returns the contigs resulting from scaffolding.
.IP "preprocess_libs Process a library hash generated with the read_lib_file subroutine. For each library, check to see if an error corrected version exists, and swap that into the hash if so. Then, do initial insert size estimates for each library. After estimating insert sizes, merge libraries with similar insert size distributions using the subroutine aggregate_libs. Insert size distributions are deemed similiar if their calculated ranges overlap. If two libraries are merged, the insert size of the resulting merged libarary is recalculated. Lastly, for each library, create a library file for \s-1SSPACE\s0>" 4
.IX Item "preprocess_libs Process a library hash generated with the read_lib_file subroutine. For each library, check to see if an error corrected version exists, and swap that into the hash if so. Then, do initial insert size estimates for each library. After estimating insert sizes, merge libraries with similar insert size distributions using the subroutine aggregate_libs. Insert size distributions are deemed similiar if their calculated ranges overlap. If two libraries are merged, the insert size of the resulting merged libarary is recalculated. Lastly, for each library, create a library file for SSPACE>"
Takes 2 parameters: \f(CW$libsref\fR, \f(CW$ctgs\fR
where
	\f(CW$libsref\fR = a hash storing information on all the libraries passed in.
	\f(CW$ctgs\fR = contigs to use to estimate insert sizes
.Sp
Returns a new library hash containing insert size calculations and new library information for merged libraries.
.IP "aggregate_libs Recreate the library hash for the given library/libraries. Merge files if an aggregate of libraries is passed in. Calculate the insert size of the final library." 4
.IX Item "aggregate_libs Recreate the library hash for the given library/libraries. Merge files if an aggregate of libraries is passed in. Calculate the insert size of the final library."
Takes 3 parameters: \f(CW$curr_lib_file\fR, \f(CW$curr_lib\fR, \f(CW$curr_ctgs\fR
where 
	\f(CW$curr_lib_file\fR = an array of single-library hashes. If the array has multiple entries (i.e. if 
	                 an aggregate has been passed in) the corresponding libraries are merged using the
	                 subroutine merge_libraries
	\f(CW$curr_lib\fR = the id of the library being processed here
	\f(CW$curr_ctgs\fR = contigs to use for insert size calculations
.IP "print_libfile Print an \s-1SSPACE\s0 library file." 4
.IX Item "print_libfile Print an SSPACE library file."
Takes 3 parameters: \f(CW$file\fR, \f(CW$libref\fR, \f(CW$err_estimate\fR
where
	\f(CW$file\fR = the file to write the \s-1SSPACE\s0 library file to
	\f(CW$libref\fR = library hash to use to create the \s-1SSPACE\s0 library file.
	\f(CW$err_estimate\fR = the error estimate for this library to give to \s-1SSPACE\s0
.IP "print_lib_info Print library information from the given library hash to standard error." 4
.IX Item "print_lib_info Print library information from the given library hash to standard error."
.PD 0
.IP "merge_libraries Merge library files corresponding to the libraries given by the array of library hashes." 4
.IX Item "merge_libraries Merge library files corresponding to the libraries given by the array of library hashes."
.PD
Takes 2 parameters: \f(CW$curr_lib_file\fR, \f(CW$curr_lib\fR
where
	\f(CW$curr_lib_file\fR = an array of single-library hashes. 
	\f(CW$curr_lib\fR = the id of the library being processed here
.Sp
Returns an array with the resulting files.
.IP "break_all_misasms Using the A5QC algorithm, remove any misassembled regions from the given contigs using the given libraries." 4
.IX Item "break_all_misasms Using the A5QC algorithm, remove any misassembled regions from the given contigs using the given libraries."
Takes 3 parameters: \f(CW$ctgs\fR, \f(CW$libsref\fR, \f(CW$outbase\fR
where
	\f(CW$ctgs\fR = the contigs to remove misassemblies from
	\f(CW$libsref\fR = a hash storing information on all the libraries passed in.
	\f(CW$outbase\fR = the basename for output generated throughout this subroutine
.Sp
Return the contigs resulting from removing misassemblies.
.IP "break_misasms Remove any misassmblies from the given contigs using the given paired library." 4
.IX Item "break_misasms Remove any misassmblies from the given contigs using the given paired library."
Takes 5 parameters: \f(CW$ctgs\fR, \f(CW$fq1\fR, \f(CW$fq2\fR, \f(CW$outbase\fR, \f(CW$nlibs\fR
where
	\f(CW$ctgs\fR = the contigs to remove misassemblies from
	\f(CW$fq1\fR = read 1 in the paired library
	\f(CW$fq2\fR = read 2 in the paired library
	\f(CW$outbase\fR = the basename for output generated throughout this subroutine
	\f(CW$nlibs\fR = the number of libraries in the paired library. Use to indicate if this
	         library is the result of merging similiar libraries or if there is an 
	         expected shadow library.
.IP "pipe_fastq Write fastq data from an input stream to an output stream, reverse completmenting fastq entries if indicated." 4
.IX Item "pipe_fastq Write fastq data from an input stream to an output stream, reverse completmenting fastq entries if indicated."
Takes 3 parameters: \f(CW$from\fR, \f(CW$to\fR, \f(CW$rc\fR
where
	\f(CW$from\fR = the input stream to read from
	\f(CW$to\fR = the output stream to write to
	\f(CW$rc\fR = a binary value indicating whethere or not fastq entries should be reverse complemented
.IP "calc_explinks Calculate the expected number of read pairs to span a point in the assembly." 4
.IX Item "calc_explinks Calculate the expected number of read pairs to span a point in the assembly."
.PD 0
.ie n .IP "run_sspace Run \s-1SSPACE\s0 using the given parameters and data. Takes 7 parametes: $genome_size $insert_size $exp_links $outbase $libfile $input_fa $rescaffold $genome_size = the expected size of the genome (used to calculate \s-1SSPACE\s0 parameters) $insert_size = the insert size of the library (used to calculate \s-1SSPACE\s0 parameters) $exp_links = the expected links to span a point in the contigs we are scaffold $outbase = the basename for output generated throughout this subroutine $libfile = the \s-1SSPACE\s0 library file to give \s-1SSPACE\s0 $input_fa = the contigs to scaffold $rescaffold = a binary value indicating whether or not we are scaffolding our assembly for the first time (i.e. scaffolding contigs generated from \s-1IDBA\s0), indicated by a 0, or if we are scaffolding for the second time (i.e. scaffolding scaffolds broken by the A5qc algorithm), indicated by a 1." 4
.el .IP "run_sspace Run \s-1SSPACE\s0 using the given parameters and data. Takes 7 parametes: \f(CW$genome_size\fR \f(CW$insert_size\fR \f(CW$exp_links\fR \f(CW$outbase\fR \f(CW$libfile\fR \f(CW$input_fa\fR \f(CW$rescaffold\fR \f(CW$genome_size\fR = the expected size of the genome (used to calculate \s-1SSPACE\s0 parameters) \f(CW$insert_size\fR = the insert size of the library (used to calculate \s-1SSPACE\s0 parameters) \f(CW$exp_links\fR = the expected links to span a point in the contigs we are scaffold \f(CW$outbase\fR = the basename for output generated throughout this subroutine \f(CW$libfile\fR = the \s-1SSPACE\s0 library file to give \s-1SSPACE\s0 \f(CW$input_fa\fR = the contigs to scaffold \f(CW$rescaffold\fR = a binary value indicating whether or not we are scaffolding our assembly for the first time (i.e. scaffolding contigs generated from \s-1IDBA\s0), indicated by a 0, or if we are scaffolding for the second time (i.e. scaffolding scaffolds broken by the A5qc algorithm), indicated by a 1." 4
.IX Item "run_sspace Run SSPACE using the given parameters and data. Takes 7 parametes: $genome_size $insert_size $exp_links $outbase $libfile $input_fa $rescaffold $genome_size = the expected size of the genome (used to calculate SSPACE parameters) $insert_size = the insert size of the library (used to calculate SSPACE parameters) $exp_links = the expected links to span a point in the contigs we are scaffold $outbase = the basename for output generated throughout this subroutine $libfile = the SSPACE library file to give SSPACE $input_fa = the contigs to scaffold $rescaffold = a binary value indicating whether or not we are scaffolding our assembly for the first time (i.e. scaffolding contigs generated from IDBA), indicated by a 0, or if we are scaffolding for the second time (i.e. scaffolding scaffolds broken by the A5qc algorithm), indicated by a 1."
.PD
Return the scaffolds resulting from running \s-1SSPACE\s0
.IP "get_genome_size Read the given fasta file, calculating the size the genome in said file." 4
.IX Item "get_genome_size Read the given fasta file, calculating the size the genome in said file."
.PD 0
.IP "get_insert Calculate the insert size of the given library using the A5 GetInsertSize.jar code." 4
.IX Item "get_insert Calculate the insert size of the given library using the A5 GetInsertSize.jar code."
.PD
Takes 4 parameters: \f(CW$r1fq\fR, \f(CW$r2fq\fR, \f(CW$outbase\fR, \f(CW$ctgs\fR
where
	\f(CW$r1fq\fR = read 1 in the paired library
	\f(CW$r2fq\fR = read 2 in the paired library
	\f(CW$outbase\fR = the basename for output generated throughout this subroutine
	\f(CW$ctgs\fR = the contigs to use to calculate the insert size
.IP "get_rdlen Return the read length of reads in the given fastq/a. This assumes that all reads in the given file are the same length" 4
.IX Item "get_rdlen Return the read length of reads in the given fastq/a. This assumes that all reads in the given file are the same length"
.PD 0
.IP "shuffleSequences shuffling fastq reads into 1 file & checking headers" 4
.IX Item "shuffleSequences shuffling fastq reads into 1 file & checking headers"
.PD
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 396:" 4
.IX Item "Around line 396:"
\&'=item' outside of any '=over'
